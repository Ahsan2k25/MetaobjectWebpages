{% assign current_metaobject = metaobject %}

<section class="dealer-listing">
  <div class="container">
    <div class="dealer-breadcrumbs font-calling-code">
      <a href="/pages/configurators" class="font-calling-code">SHOP ALL</a> / <span class="font-calling-code">ARTAFEX 4 CONFIGURATORS</span>
    </div>

    <div class="dealer-top-header">
      <h2 class="dealer-top-heading font-neue-roman">{{ current_metaobject.collection_name }} Configurators</h2>
      <div class="collections-navigation" id="collections-navigation">
        <ul></ul>
      </div>
    </div>

    <!-- Pass the raw JSON string as a data attribute -->
    <div id="collection-data" data-refs='{{ current_metaobject.configurator_nested_collection }}' style="display:none;"></div>

    <div class="nested-collections" id="nested-collections">
      <div class="dealer-collection-box"></div>
    </div>
  </div>
</section>
<div class="configurator-landing">
  
  
  <div class="configurator-collection">
    {% comment %} <h2>{{ current_metaobject.collection_name }}</h2>
    <div class="collections-navigation" id="collections-navigation">
      <ul>
        <li></li>
      </ul>
    </div> {% endcomment %}
    
    
    
    
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const nestedContainer = document.getElementById('nested-collections');
    const navContainer = document.getElementById('collections-navigation').querySelector('ul');
    
    // Get the raw JSON string from the data attribute
    const dataElement = document.getElementById('collection-data');
    const rawJson = dataElement.getAttribute('data-refs');
    console.log('Raw JSON from data attribute:', rawJson);
    
    // Parse the JSON string to get the array of GIDs
    let nestedCollectionIds;
    try {
      nestedCollectionIds = JSON.parse(rawJson);
      console.log('Parsed collection IDs:', nestedCollectionIds);
    } catch (error) {
      console.error('Error parsing collection references:', error);
      nestedContainer.innerHTML = '<div>Error parsing collection references</div>';
      navContainer.innerHTML = '<li>Error loading collections</li>';
      return;
    }
    
    // Storefront API Configuration
    const storefrontApiToken = 'c728f2cb977d44d8991f690f5ef1d3f3';
    const shopDomain = window.location.hostname;
    const storefrontApiUrl = `https://${shopDomain}/api/2023-01/graphql.json`;
    
    // Function to fetch metaobjects using the Storefront API
    async function fetchNestedCollections() {
      // Query to get nested collections and their product card references
      const query = `
        {
          nodes(ids: ${JSON.stringify(nestedCollectionIds)}) {
            ... on Metaobject {
              id
              handle
              type
              fields {
                key
                value
              }
            }
          }
        }
      `;
      
      try {
        const response = await fetch(storefrontApiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Shopify-Storefront-Access-Token': storefrontApiToken
          },
          body: JSON.stringify({ query })
        });
        
        if (!response.ok) {
          throw new Error(`API response: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.errors) {
          throw new Error(data.errors.map(e => e.message).join(', '));
        }
        
        return data.data?.nodes || [];
      } catch (error) {
        console.error('Error fetching nested collections:', error);
        throw error;
      }
    }
    
    // Function to fetch product cards by their IDs
    async function fetchProductCards(productCardIds) {
      if (!productCardIds || productCardIds.length === 0) {
        return [];
      }
      
      // Clean up the IDs - they're likely in a JSON string format
      const cleanIds = productCardIds.map(id => {
        if (typeof id === 'string') {
          // If it's already a GID, use it as is
          if (id.startsWith('gid://')) {
            return id;
          }
          // Otherwise, it might be a numeric ID that needs to be converted to a GID
          return `gid://shopify/Metaobject/${id}`;
        }
        return null;
      }).filter(Boolean);
      
      if (cleanIds.length === 0) {
        return [];
      }
      
      // Query to get product cards
      const query = `
        {
          nodes(ids: ${JSON.stringify(cleanIds)}) {
            ... on Metaobject {
              id
              handle
              type
              fields {
                key
                value
              }
            }
          }
        }
      `;
      
      try {
        const response = await fetch(storefrontApiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Shopify-Storefront-Access-Token': storefrontApiToken
          },
          body: JSON.stringify({ query })
        });
        
        if (!response.ok) {
          throw new Error(`API response: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.errors) {
          throw new Error(data.errors.map(e => e.message).join(', '));
        }
        
        return data.data?.nodes || [];
      } catch (error) {
        console.error('Error fetching product cards:', error);
        return [];
      }
    }
    
    // Function to process metaobject fields
    function processMetaobjectFields(metaobject) {
      if (!metaobject || !metaobject.fields) {
        return {};
      }
      
      const fields = {};
      
      metaobject.fields.forEach(field => {
        if (field.key) {
          fields[field.key] = field.value;
        }
      });
      
      return fields;
    }
    
    // Extract product card IDs from a nested collection
    function extractProductCardIds(nestedCollection) {
      const fields = processMetaobjectFields(nestedCollection);
      
      if (!fields.product_cards) {
        return [];
      }
      
      // Try to parse the product_cards value as JSON
      try {
        const productCards = JSON.parse(fields.product_cards);
        return Array.isArray(productCards) ? productCards : [];
      } catch (e) {
        console.error('Error parsing product cards:', e);
        return [];
      }
    }
    
    // Main function to load data
    async function loadNestedCollections() {
      try {
        // Fetch the nested collections
        const nestedCollections = await fetchNestedCollections();
        
        if (!nestedCollections || nestedCollections.length === 0) {
          nestedContainer.innerHTML = '<p>No nested collections found.</p>';
          navContainer.innerHTML = '<li>No collections available</li>';
          return;
        }
        
        console.log('Fetched nested collections:', nestedCollections);
        
        // Group collections by name to avoid duplicates in navigation
        const collectionGroups = {};
        const uniqueNames = new Set();
        
        // Process each collection and organize them by name
        nestedCollections.forEach(collection => {
          const fields = processMetaobjectFields(collection);
          const collectionName = fields.collection_name || collection.handle || 'Unnamed Collection';
          
          // Add to unique names set
          uniqueNames.add(collectionName);
          
          // Add to group
          if (!collectionGroups[collectionName]) {
            collectionGroups[collectionName] = [];
          }
          collectionGroups[collectionName].push(collection);
        });
        
        console.log('Collection groups:', collectionGroups);
        
        // Build navigation with unique names
        let navHtml = '';
        let activeSet = false;
        
        // Convert Set to Array and sort alphabetically
        const sortedUniqueNames = Array.from(uniqueNames).sort();
        
        sortedUniqueNames.forEach(name => {
          const collections = collectionGroups[name];
          if (!collections || collections.length === 0) return;
          
          // Use the first collection in each group for the navigation link
          const firstCollection = collections[0];
          
          // Set active class on first nav item only
          const isActive = !activeSet;
          if (isActive) activeSet = true;
          
          navHtml += `
            <li>
              <a href="#collection-${firstCollection.handle}" 
                 data-collection-name="${name}"
                 class="${isActive ? 'active' : ''}">
                ${name}
              </a>
            </li>
          `;
        });
        
        navContainer.innerHTML = navHtml;
        
        // Build collections content
        let collectionsHtml = '';
        
        // Process each nested collection
        for (const nestedCollection of nestedCollections) {
          const fields = processMetaobjectFields(nestedCollection);
          console.log('Nested collection fields:', fields);
          
          // Start building the HTML for this collection
          let collectionHtml = `
            <div id="collection-${nestedCollection.handle}" class="dealer-collection-box nested-collection" data-name="${fields.collection_name || 'Unnamed Collection'}">
              <h2>${fields.collection_display_name || 'Nested Collection'}</h2>
          `;
          
          // Extract product card IDs
          const productCardIds = extractProductCardIds(nestedCollection);
          console.log('Product card IDs:', productCardIds);
          
          // Fetch the product cards
          const productCards = await fetchProductCards(productCardIds);
          console.log('Fetched product cards:', productCards);
          
          // Add product cards section
          collectionHtml += '<div class="dealer-collections-listing-carousel">';
          
          if (productCards && productCards.length > 0) {
            // Process each product card
            for (const productCard of productCards) {
              const cardFields = processMetaobjectFields(productCard);
              console.log('Product card fields:', cardFields);
              
              collectionHtml += `
                <div class="dealer-collections-list-item">
                  <div class="product-image">
                    <img src="${getShopifyImageUrl(cardFields.product_image)}" alt="${cardFields.product_name || 'Product'}" width="226" height="305">
                  </div>
                  <div class="dealer-collections-list-content">
                    <h3 class="product-title font-neue-roman">${cardFields.product_name || 'Product'}</h3>
                    ${cardFields.configure_button_text ? 
                      `<div class="product-button">
                        <a href="${cardFields.configure_button_url || '#'}" class="btn font-neue-roman">
                          ${cardFields.configure_button_text}
                        </a>
                      </div>` : ''}
                    </div>
                </div>
              `;
            }
          } else {
            // If no product cards were found, show placeholders
            collectionHtml += `
              <div class="dealer-collections-list-item">
               No product cards found!
              </div>
            `;
          }
          
          collectionHtml += '</div></div>';
          collectionsHtml += collectionHtml;
        }
        
        nestedContainer.innerHTML = collectionsHtml;
        
        // Add click event listeners to navigate between collections
        const navLinks = navContainer.querySelectorAll('a');
        navLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Remove active class from all links
            navLinks.forEach(l => l.classList.remove('active'));
            
            // Add active class to clicked link
            this.classList.add('active');
            
            // Get the collection name for this navigation item
            const collectionName = this.getAttribute('data-collection-name');
            
            // Find the first collection with this name
            const targetId = this.getAttribute('href');
            const targetElement = document.querySelector(targetId);
            
            if (targetElement) {
              targetElement.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
              });
            }
          });
        });
      } catch (error) {
        console.error('Error:', error);
        
        // Show error and fall back to a simple error message
        navContainer.innerHTML = '<li>Error loading collections</li>';
        nestedContainer.innerHTML = `<div>Error loading collections: ${error.message}</div>`;
      }
    }

    function getShopifyImageUrl(imageUrl) {
    if (!imageUrl || typeof imageUrl !== 'string') {
      return 'https://via.placeholder.com/300x200';
    }

    console.log('Image URL: '+imageUrl);

    return imageUrl.startsWith('cdn') ? imageUrl : 'https://via.placeholder.com/300x200';
  }

    
    // Start loading
    loadNestedCollections();
  });
</script>

{% schema %}
  {
    "name": "Configurator Listing",
    "settings": [],
    "presets": [
      {
        "name": "Configurator Listing"
      }
    ]
  }
{% endschema %}